package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"server/internal/db"
	"server/internal/graph/model"
	"server/internal/loader"

	"github.com/jackc/pgx/v5/pgtype"
)

// Images is the resolver for the images field.
func (r *listingResolver) Images(ctx context.Context, obj *model.Listing) ([]*model.ListingImage, error) {
	loaders := loader.For(ctx)
	return loaders.ListingImageLoader.Load(ctx, obj.ID)
}

// Listings is the resolver for the listings field.
func (r *queryResolver) Listings(ctx context.Context, minLatitude float64, maxLatitude float64, minLongitude float64, maxLongitude float64, address *string, minPrice *int64, maxPrice *int64, occupancyStatuses []db.OccupancyStatus) (*model.ListingConnection, error) {
	params := db.GetListingsInBoundaryParams{
		MinLat:            minLatitude,
		MaxLat:            maxLatitude,
		MinLng:            minLongitude,
		MaxLng:            maxLongitude,
		Sources:           []db.Source{db.SourcePagibig, db.SourceSecbank, db.SourceUnionbank},
		OccupancyStatuses: []db.OccupancyStatus{db.OccupancyStatusOccupied, db.OccupancyStatusUnoccupied, db.OccupancyStatusUnspecified},
	}

	if minPrice != nil {
		params.MinPrice = *minPrice
	}

	if maxPrice != nil {
		params.MaxPrice = pgtype.Int8{Int64: *maxPrice, Valid: true}
	}

	if address != nil {
		params.Address = *address
	}

	if len(occupancyStatuses) > 0 {
		params.OccupancyStatuses = occupancyStatuses
	}

	listingsRepository := db.NewListingsRepository()
	dbListings, err := listingsRepository.GetListingsInBoundary(ctx, r.pool, params)
	if err != nil {
		return nil, err
	}

	jitterCoordinates(dbListings)

	listingNodes := make([]*model.Listing, len(dbListings))
	for i, dbListing := range dbListings {
		floorArea, err := dbListing.FloorArea.Float64Value()
		if err != nil {
			return nil, err
		}

		lotArea, err := dbListing.LotArea.Float64Value()
		if err != nil {
			return nil, err
		}

		listingNodes[i] = &model.Listing{
			ID:              dbListing.ID,
			ExternalID:      dbListing.ExternalID,
			Address:         dbListing.Address,
			Price:           dbListing.Price,
			FloorArea:       floorArea.Float64,
			LotArea:         lotArea.Float64,
			OccupancyStatus: dbListing.OccupancyStatus,
			Source:          dbListing.Source,
			Payload:         string(dbListing.Payload),
			Latitude:        dbListing.Coordinate.Y(),
			Longitude:       dbListing.Coordinate.X(),
		}
	}

	return &model.ListingConnection{Nodes: listingNodes}, nil
}

// Listing returns ListingResolver implementation.
func (r *Resolver) Listing() ListingResolver { return &listingResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type listingResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
