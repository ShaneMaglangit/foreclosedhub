package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"fmt"
	"math/rand/v2"
	"server/internal/db"
	"server/internal/graph/model"
	"server/internal/loader"

	"github.com/twpayne/go-geos"
)

const jitterDistance = 0.00001

func jitterCoordinates(listings []*db.Listing) {
	coordMap := make(map[string]int)

	for i, listing := range listings {
		key := fmt.Sprintf("%.8f,%.8f", listing.Coordinate.X(), listing.Coordinate.Y())

		count := coordMap[key]
		if count > 0 {
			newLng := listing.Coordinate.X() + (rand.Float64()*2-1)*jitterDistance
			newLat := listing.Coordinate.Y() + (rand.Float64()*2-1)*jitterDistance

			listings[i].Coordinate = geos.NewPointFromXY(newLng, newLat)

			key = fmt.Sprintf("%.8f,%.8f", newLng, newLat)
		}

		coordMap[key] = count + 1
	}
}

// ListingImages is the resolver for the listingImages field.
func (r *listingResolver) ListingImages(ctx context.Context, obj *model.Listing) ([]*model.ListingImage, error) {
	loaders := loader.For(ctx)
	return loaders.ListingImageLoader.Load(ctx, obj.ID)
}

// Listings is the resolver for the listings field.
func (r *queryResolver) Listings(ctx context.Context, minLatitude float64, maxLatitude float64, minLongitude float64, maxLongitude float64) (*model.ListingConnection, error) {
	listingsRepository := db.NewListingsRepository()
	dbListings, err := listingsRepository.GetListingsInBoundary(ctx, r.pool, db.GetListingsInBoundaryParams{
		MinLat:            minLatitude,
		MaxLat:            maxLatitude,
		MinLng:            minLongitude,
		MaxLng:            maxLongitude,
		Sources:           []db.Source{db.SourcePagibig, db.SourceSecbank},
		OccupancyStatuses: []db.OccupancyStatus{db.OccupancyStatusOccupied, db.OccupancyStatusOccupied, db.OccupancyStatusOccupied},
	})
	if err != nil {
		return nil, err
	}

	jitterCoordinates(dbListings)

	listingNodes := make([]*model.Listing, len(dbListings))
	for i, dbListing := range dbListings {
		floorArea, err := dbListing.FloorArea.Float64Value()
		if err != nil {
			return nil, err
		}

		lotArea, err := dbListing.LotArea.Float64Value()
		if err != nil {
			return nil, err
		}

		listingNodes[i] = &model.Listing{
			ID:        dbListing.ID,
			Address:   dbListing.Address,
			FloorArea: floorArea.Float64,
			LotArea:   lotArea.Float64,
			Latitude:  dbListing.Coordinate.Y(),
			Longitude: dbListing.Coordinate.X(),
		}
	}

	return &model.ListingConnection{Nodes: listingNodes}, nil
}

// Listing returns ListingResolver implementation.
func (r *Resolver) Listing() ListingResolver { return &listingResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type listingResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
